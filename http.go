package main

import (
	_ "embed"
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"strings"
)

//go:embed template/application.java.tpl
var applicationTemplate string

//go:embed template/controller.java.tpl
var controllerTemplate string

//go:embed template/enum.java.tpl
var enumTemplate string

//go:embed template/bean.java.tpl
var beanTemplate string

//go:embed version
var version string

const (
	DefaultBeanPackage        = "application.model.vo"
	DefaultEnumPackage        = "application.model.enums"
	DefaultApplicationPackage = "application.service"
	DefaultControllerPackage  = "interfaces.controller"
)

type SpringBootPlugin struct {
	version string
	plugin  *protogen.Plugin
}

func NewSpringBoot(plugin *protogen.Plugin) *SpringBootPlugin {
	return &SpringBootPlugin{
		plugin:  plugin,
		version: version,
	}
}

func (spring *SpringBootPlugin) Generate() error {
	files := spring.plugin.Files
	for _, file := range files {
		if !file.Generate {
			continue
		}
		spring.generate(file)
	}

	return nil
}

func (spring *SpringBootPlugin) generate(file *protogen.File) {
	spring.generateJavaEnums(file)
	spring.generateJavaBean(file)
	spring.generateSpringBootController(file)
	spring.generateSpringBootApplication(file)
}

func (spring *SpringBootPlugin) generateHeader(file *protogen.File) string {
	fileHeaderComment := `
// Code generated by protoc-gen-java-http. DO NOT EDIT.
// version
//  - protoc-gen-java: %s
//  - protoc: %s
// source: %s
`
	return fmt.Sprintf(strings.TrimSpace(fileHeaderComment), spring.version, ProtocVersion, file.Desc.Path())
}

func (spring *SpringBootPlugin) generateJavaBean(file *protogen.File) {
	for _, message := range file.Messages {
		for _, enum := range message.Enums {
			spring.generateJavaEnum(enum, file)
		}
		md := NewMessageTemplate(spring, message)
		g := spring.plugin.NewGeneratedFile(md.FileName(), file.GoImportPath)
		g.P(spring.generateHeader(file))
		g.P(md.Execute())
	}
}

func (spring *SpringBootPlugin) generateJavaEnums(file *protogen.File) {
	for _, enum := range file.Enums {
		spring.generateJavaEnum(enum, file)
	}
}

func (spring *SpringBootPlugin) generateJavaEnum(enum *protogen.Enum, file *protogen.File) {
	ed := NewEnumDescriptor(enum)
	g := spring.plugin.NewGeneratedFile(ed.FileName(), "")
	g.P(spring.generateHeader(file))
	g.P(ed.Execute())
}

func (spring *SpringBootPlugin) generateSpringBootController(file *protogen.File) {
	for _, service := range file.Services {
		tmpl := NewControllerTemplate(service)
		g := spring.plugin.NewGeneratedFile(tmpl.FileName(), file.GoImportPath)
		g.P(spring.generateHeader(file))
		g.P(tmpl.Execute())
	}
}

func (spring *SpringBootPlugin) generateSpringBootApplication(file *protogen.File) {
	for _, service := range file.Services {
		sd := NewApplicationJavaTemplate(service)
		g := spring.plugin.NewGeneratedFile(sd.FileName(), file.GoImportPath)
		g.P(spring.generateHeader(file))
		g.P(sd.Execute())
	}
}

func Package2Path(javaPackage string) string {
	return strings.Replace(javaPackage, ".", "/", -1)
}

func ApplicationPackageName(service *protogen.Service) string {
	options := service.Desc.ParentFile().Options().(*descriptorpb.FileOptions)
	return *options.JavaPackage + "." + DefaultApplicationPackage
}

func ControllerPackageName(service *protogen.Service) string {
	options := service.Desc.ParentFile().Options().(*descriptorpb.FileOptions)
	return *options.JavaPackage + "." + DefaultControllerPackage
}

func BeanPackageName(message *protogen.Message) string {
	options := message.Desc.ParentFile().Options().(*descriptorpb.FileOptions)
	return strings.Join([]string{*options.JavaPackage, DefaultBeanPackage}, ".")
}

func EnumPackageName(enum *protogen.Enum) string {
	options := enum.Desc.ParentFile().Options().(*descriptorpb.FileOptions)
	return strings.Join([]string{*options.JavaPackage, DefaultEnumPackage}, ".")
}

func BeanImportPath(message *protogen.Message) string {
	return BeanPackageName(message) + "." + string(message.Desc.Name())
}

func BeanImportPaths(message *protogen.Message) []string {
	paths := make([]string, 0)
	paths = append(paths, BeanImportPath(message))
	for _, field := range message.Fields {
		if path, ok := FieldImportPath(field); ok {
			paths = append(paths, path)
		}
	}

	return paths
}

func FieldImportPath(field *protogen.Field) (string, bool) {
	if field.Desc.IsMap() && !IsSampleType(field.Desc.MapValue().Kind()) {
		return BeanImportPath(field.Message.Fields[1].Message), true
	} else if field.Desc.IsList() && !IsSampleType(field.Desc.Kind()) {
		return BeanImportPath(field.Message), true
	} else if field.Desc.Kind() == protoreflect.MessageKind {
		return BeanImportPath(field.Message), true
	} else if field.Desc.Kind() == protoreflect.EnumKind {
		return EnumImportPath(field.Enum), true
	}
	return "", false
}

func ApplicationImportPath(service *protogen.Service) string {
	return ApplicationPackageName(service) + "." + ApplicationServiceName(service)
}

func ApplicationServiceName(service *protogen.Service) string {
	return strings.Replace(service.GoName, "Service", "", -1) + "ApplicationService"
}

func ControllerName(service *protogen.Service) string {
	return strings.Replace(service.GoName, "Service", "", -1) + "Controller"
}

func EnumImportPath(enum *protogen.Enum) string {
	return EnumPackageName(enum) + "." + string(enum.Desc.Name())
}

func IsSampleType(kind protoreflect.Kind) bool {
	if kind == protoreflect.MessageKind || kind == protoreflect.EnumKind {
		return false
	} else {
		return true
	}
}
